name: 🛡️ 고급 보안 스캔 및 검증

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    - cron: '0 3 * * *'  # 매일 오후 12시 (KST)
  workflow_dispatch:
    inputs:
      security_level:
        description: '보안 검사 수준'
        required: true
        default: 'standard'
        type: choice
        options:
          - minimal
          - standard
          - comprehensive
          - penetration-test

env:
  NODE_VERSION: '20'
  SECURITY_SCAN_TIMEOUT: '30'

jobs:
  # OWASP Top 10 자동 스캔
  owasp-security:
    name: 🔍 OWASP Top 10 보안 스캔
    runs-on: ubuntu-latest
    timeout-minutes: 35
    
    steps:
      - name: 📥 코드 체크아웃
        uses: actions/checkout@v4

      - name: 🔧 Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: 📦 의존성 설치
        run: |
          npm ci --no-audit --no-fund
          npm install --no-save @playwright/test

      - name: 🏗️ 보안 테스트용 빌드
        env:
          NEXT_PUBLIC_SUPABASE_URL: ${{ secrets.NEXT_PUBLIC_SUPABASE_URL || 'https://placeholder.supabase.co' }}
          NEXT_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY || 'placeholder_key' }}
        run: |
          echo "🔨 보안 테스트용 프로덕션 빌드..."
          NODE_ENV=production npm run build

      - name: 🚀 테스트 서버 시작
        run: |
          npm start &
          SERVER_PID=$!
          echo "SERVER_PID=$SERVER_PID" >> $GITHUB_ENV
          
          echo "⏳ 서버 시작 대기..."
          for i in {1..30}; do
            if curl -s http://localhost:3000 > /dev/null; then
              echo "✅ 서버 준비 완료"
              break
            fi
            sleep 2
          done

      - name: 🛡️ OWASP ZAP 베이스라인 스캔
        uses: zaproxy/action-baseline@v0.12.0
        with:
          target: 'http://localhost:3000'
          rules_file_name: '.zap/rules.tsv'
          cmd_options: '-a -x zap-report.xml -r zap-report.html'
          allow_issue_writing: false

      - name: 📊 OWASP Top 10 맞춤 검증
        run: |
          cat > owasp-security-test.js << 'EOF'
          const { test, expect } = require('@playwright/test');
          
          test.describe('OWASP Top 10 Security Tests', () => {
            
            // A01:2021 – Broken Access Control
            test('Access Control Verification', async ({ page }) => {
              console.log('🔍 A01: 접근 제어 검증');
              
              // 인증이 필요한 페이지들 테스트
              const protectedRoutes = ['/admin', '/dashboard', '/profile'];
              
              for (const route of protectedRoutes) {
                const response = await page.goto(`http://localhost:3000${route}`, { waitUntil: 'networkidle' });
                
                // 인증되지 않은 접근 시 적절한 리다이렉션이나 에러 처리 확인
                if (response.status() === 200) {
                  const currentUrl = page.url();
                  if (!currentUrl.includes('/auth') && !currentUrl.includes('/login')) {
                    console.warn(`⚠️ 보호된 라우트 ${route}에 직접 접근 가능`);
                  } else {
                    console.log(`✅ ${route}: 적절히 보호됨`);
                  }
                } else if ([401, 403, 302].includes(response.status())) {
                  console.log(`✅ ${route}: HTTP ${response.status()} - 적절한 접근 제어`);
                }
              }
            });
          
            // A02:2021 – Cryptographic Failures
            test('Cryptographic Implementation', async ({ page }) => {
              console.log('🔍 A02: 암호화 구현 검증');
              
              await page.goto('http://localhost:3000');
              
              // HTTPS 리다이렉션 확인
              const protocol = new URL(page.url()).protocol;
              if (process.env.NODE_ENV === 'production' && protocol !== 'https:') {
                console.warn('⚠️ 프로덕션에서 HTTPS 사용 권장');
              }
              
              // 민감한 데이터 저장소 확인
              const localStorage = await page.evaluate(() => Object.keys(localStorage));
              const sessionStorage = await page.evaluate(() => Object.keys(sessionStorage));
              
              const sensitivePatterns = ['password', 'token', 'secret', 'key', 'auth'];
              const suspiciousLocal = localStorage.filter(key => 
                sensitivePatterns.some(pattern => key.toLowerCase().includes(pattern))
              );
              const suspiciousSession = sessionStorage.filter(key => 
                sensitivePatterns.some(pattern => key.toLowerCase().includes(pattern))
              );
              
              if (suspiciousLocal.length > 0) {
                console.warn(`⚠️ localStorage에 민감한 데이터 가능: ${suspiciousLocal.join(', ')}`);
              }
              if (suspiciousSession.length > 0) {
                console.warn(`⚠️ sessionStorage에 민감한 데이터 가능: ${suspiciousSession.join(', ')}`);
              }
            });
          
            // A03:2021 – Injection
            test('Injection Attack Prevention', async ({ page }) => {
              console.log('🔍 A03: 인젝션 공격 방지 검증');
              
              await page.goto('http://localhost:3000');
              
              // 검색이나 입력 폼이 있는지 확인
              const inputFields = await page.locator('input[type="text"], input[type="search"], textarea').count();
              
              if (inputFields > 0) {
                const testPayloads = [
                  '<script>alert("XSS")</script>',
                  "'; DROP TABLE users; --",
                  '{{7*7}}',
                  '${7*7}',
                  'javascript:alert("XSS")'
                ];
                
                for (const payload of testPayloads.slice(0, 2)) {
                  try {
                    const firstInput = page.locator('input[type="text"], input[type="search"], textarea').first();
                    await firstInput.fill(payload);
                    await firstInput.press('Enter');
                    await page.waitForTimeout(1000);
                    
                    // 페이지에서 스크립트가 실행되었는지 확인
                    const alertHandled = await page.evaluate(() => {
                      return window.hasOwnProperty('alert') && typeof window.alert === 'function';
                    });
                    
                    console.log(`✅ Payload "${payload.substring(0, 20)}..." 처리됨`);
                  } catch (error) {
                    console.log(`✅ 인젝션 방어: ${error.message}`);
                  }
                }
              } else {
                console.log('ℹ️ 테스트 가능한 입력 필드 없음');
              }
            });
          
            // A04:2021 – Insecure Design
            test('Secure Design Patterns', async ({ page }) => {
              console.log('🔍 A04: 보안 설계 패턴 검증');
              
              await page.goto('http://localhost:3000');
              
              // 보안 헤더 확인
              const response = await page.goto('http://localhost:3000');
              const headers = response.headers();
              
              const securityHeaders = {
                'x-frame-options': 'Clickjacking 방지',
                'x-content-type-options': 'MIME 스니핑 방지',
                'x-xss-protection': 'XSS 방지',
                'strict-transport-security': 'HTTPS 강제',
                'content-security-policy': 'CSP 정책',
                'referrer-policy': 'Referrer 정책'
              };
              
              let securityScore = 0;
              for (const [header, description] of Object.entries(securityHeaders)) {
                if (headers[header]) {
                  console.log(`✅ ${header}: ${description}`);
                  securityScore++;
                } else {
                  console.warn(`⚠️ ${header} 헤더 누락: ${description}`);
                }
              }
              
              console.log(`📊 보안 헤더 점수: ${securityScore}/${Object.keys(securityHeaders).length}`);
            });
          
            // A05:2021 – Security Misconfiguration
            test('Security Configuration', async ({ page }) => {
              console.log('🔍 A05: 보안 구성 검증');
              
              // 개발 모드 흔적 확인
              const response = await page.goto('http://localhost:3000');
              const pageContent = await page.content();
              
              const developmentIndicators = [
                'development',
                'debug',
                'console.log',
                'localhost',
                'test-',
                'demo-'
              ];
              
              const foundIndicators = developmentIndicators.filter(indicator => 
                pageContent.toLowerCase().includes(indicator)
              );
              
              if (foundIndicators.length > 0 && process.env.NODE_ENV === 'production') {
                console.warn(`⚠️ 프로덕션에서 개발 모드 흔적: ${foundIndicators.join(', ')}`);
              }
              
              // 에러 페이지 정보 노출 확인
              try {
                await page.goto('http://localhost:3000/nonexistent-page');
                const errorContent = await page.content();
                
                if (errorContent.includes('stack') || errorContent.includes('Error:') || errorContent.includes('at ')) {
                  console.warn('⚠️ 에러 페이지에서 스택 트레이스 노출');
                } else {
                  console.log('✅ 에러 페이지 정보 적절히 제한됨');
                }
              } catch (error) {
                console.log('✅ 404 페이지 적절히 처리됨');
              }
            });
          
            // A06:2021 – Vulnerable and Outdated Components
            test('Component Vulnerability Check', async ({ page }) => {
              console.log('🔍 A06: 구성 요소 취약점 검증');
              
              await page.goto('http://localhost:3000');
              
              // 클라이언트 사이드 라이브러리 버전 확인
              const libraryVersions = await page.evaluate(() => {
                const versions = {};
                
                // React 버전 확인
                if (window.React) {
                  versions.react = window.React.version;
                }
                
                // jQuery 버전 확인
                if (window.jQuery) {
                  versions.jquery = window.jQuery.fn.jquery;
                }
                
                // 기타 전역 라이브러리들
                const globalLibs = ['moment', 'lodash', '_'];
                globalLibs.forEach(lib => {
                  if (window[lib] && window[lib].version) {
                    versions[lib] = window[lib].version;
                  }
                });
                
                return versions;
              });
              
              console.log('📚 발견된 클라이언트 라이브러리:', libraryVersions);
              
              // package.json에서 의존성 확인은 별도 단계에서 수행
            });
          
            // A07:2021 – Identification and Authentication Failures
            test('Authentication Security', async ({ page }) => {
              console.log('🔍 A07: 인증 보안 검증');
              
              // 로그인 페이지가 있는지 확인
              const loginResponse = await page.goto('http://localhost:3000/auth/login', { waitUntil: 'networkidle' });
              
              if (loginResponse.status() === 200) {
                // 패스워드 정책 확인
                const passwordInput = page.locator('input[type="password"]');
                if (await passwordInput.count() > 0) {
                  // 브루트 포스 방지 확인 (rate limiting)
                  console.log('🔐 패스워드 입력 필드 발견');
                  
                  // 패스워드 표시/숨김 토글 확인
                  const showPasswordToggle = page.locator('button[aria-label*="password"], [data-testid*="password-toggle"]');
                  if (await showPasswordToggle.count() > 0) {
                    console.log('✅ 패스워드 표시/숨김 기능 있음');
                  }
                  
                  // 자동완성 설정 확인
                  const autocompleteAttr = await passwordInput.first().getAttribute('autocomplete');
                  if (autocompleteAttr === 'current-password' || autocompleteAttr === 'new-password') {
                    console.log('✅ 적절한 autocomplete 설정');
                  }
                }
                
                // 회원가입 보안 확인
                const signupResponse = await page.goto('http://localhost:3000/auth/signup');
                if (signupResponse.status() === 200) {
                  const emailInput = page.locator('input[type="email"]');
                  if (await emailInput.count() > 0) {
                    console.log('✅ 이메일 기반 계정 시스템');
                  }
                }
              } else {
                console.log('ℹ️ 인증 시스템 없음');
              }
            });
          
            // A10:2021 – Server-Side Request Forgery (SSRF)
            test('SSRF Prevention', async ({ page }) => {
              console.log('🔍 A10: SSRF 방지 검증');
              
              await page.goto('http://localhost:3000');
              
              // API 엔드포인트에서 외부 URL 요청 기능 확인
              const apiCalls = [];
              page.on('request', request => {
                if (request.url().includes('/api/')) {
                  apiCalls.push(request.url());
                }
              });
              
              // 페이지 인터랙션으로 API 호출 유발
              await page.waitForTimeout(2000);
              
              if (apiCalls.length > 0) {
                console.log(`📡 API 호출 감지: ${apiCalls.length}개`);
                console.log('💡 API 엔드포인트에서 URL 검증 확인 필요');
              } else {
                console.log('ℹ️ API 호출 감지되지 않음');
              }
            });
          });
          EOF
          
          npx playwright test owasp-security-test.js --reporter=json:owasp-results.json

      - name: 🧹 서버 정리
        if: always()
        run: |
          if [ -n "$SERVER_PID" ]; then
            kill $SERVER_PID || true
          fi
          pkill -f "next start" || true

      - name: 📤 OWASP 스캔 결과 업로드
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: owasp-security-results
          path: |
            zap-report.xml
            zap-report.html
            owasp-results.json
          retention-days: 30

  # 환경변수 및 시크릿 고급 검사
  secrets-advanced-scan:
    name: 🔐 고급 시크릿 스캔
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    steps:
      - name: 📥 코드 체크아웃
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 🔧 Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: 🔍 TruffleHog 고급 시크릿 스캔
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: HEAD~1
          head: HEAD
          extra_args: --no-verification --allow-verification-overlap --json

      - name: 🕵️ GitLeaks 설정 및 스캔
        run: |
          # GitLeaks 설정 파일 생성
          cat > .gitleaks.toml << 'EOF'
          title = "dduksangLAB GitLeaks Config"
          
          [[rules]]
          description = "AWS Access Key ID"
          regex = '''AKIA[0-9A-Z]{16}'''
          tags = ["key", "AWS"]
          
          [[rules]]
          description = "AWS Secret Access Key"
          regex = '''[A-Za-z0-9/\+=]{40}'''
          tags = ["key", "AWS"]
          
          [[rules]]
          description = "Supabase Keys"
          regex = '''eyJ[A-Za-z0-9-_]*\.[A-Za-z0-9-_]*\.[A-Za-z0-9-_]*'''
          tags = ["key", "Supabase", "JWT"]
          
          [[rules]]
          description = "Generic API Keys"
          regex = '''(?i)(api[_-]?key|apikey)['"\s]*[:=]\s*['"][a-z0-9]{16,}['"]'''
          tags = ["key", "API"]
          
          [[rules]]
          description = "Generic Secrets"
          regex = '''(?i)(secret|token|password)['"\s]*[:=]\s*['"][a-z0-9!@#$%^&*()_+\-=\[\]{}|;:,.<>?]{8,}['"]'''
          tags = ["secret"]
          
          [[rules]]
          description = "Database URLs"
          regex = '''(?i)(database_url|db_url|mongo_url)['"\s]*[:=]\s*['"][a-z0-9\-\.:/@]+['"]'''
          tags = ["database"]
          
          [[rules]]
          description = "Private Keys"
          regex = '''-----BEGIN [A-Z]+ PRIVATE KEY-----'''
          tags = ["key", "private"]
          
          # 허용할 파일들 (false positives 방지)
          [allowlist]
          paths = [
            ".gitleaks.toml",
            ".env.example",
            "docs/",
            "README.md"
          ]
          EOF
          
          # GitLeaks 실행
          curl -sSfL https://github.com/gitleaks/gitleaks/releases/latest/download/gitleaks_linux_x64.tar.gz | tar -xz
          ./gitleaks detect --config=.gitleaks.toml --report-format=json --report-path=gitleaks-report.json --verbose

      - name: 🔎 환경변수 사용 패턴 분석
        run: |
          echo "🔍 환경변수 사용 패턴 분석..."
          
          cat > env-pattern-analyzer.js << 'EOF'
          const fs = require('fs');
          const path = require('path');
          
          function analyzeEnvUsage(dir) {
            const results = {
              envReferences: [],
              potentialLeaks: [],
              hardcodedValues: [],
              configFiles: []
            };
            
            function scanDirectory(currentDir) {
              const items = fs.readdirSync(currentDir);
              
              for (const item of items) {
                const fullPath = path.join(currentDir, item);
                const stat = fs.statSync(fullPath);
                
                // 제외할 디렉토리들
                const excludeDirs = ['node_modules', '.next', '.git', 'dist', 'build'];
                if (stat.isDirectory() && !excludeDirs.includes(item)) {
                  scanDirectory(fullPath);
                } else if (stat.isFile()) {
                  scanFile(fullPath);
                }
              }
            }
            
            function scanFile(filePath) {
              const ext = path.extname(filePath);
              const allowedExts = ['.js', '.ts', '.jsx', '.tsx', '.json', '.env'];
              
              if (!allowedExts.includes(ext)) return;
              
              try {
                const content = fs.readFileSync(filePath, 'utf8');
                
                // 환경변수 참조 찾기
                const envMatches = content.match(/process\.env\.[A-Z_][A-Z0-9_]*/g) || [];
                envMatches.forEach(match => {
                  results.envReferences.push({
                    file: filePath,
                    variable: match,
                    line: content.split('\n').findIndex(line => line.includes(match)) + 1
                  });
                });
                
                // 하드코딩된 값 찾기
                const hardcodedPatterns = [
                  /['"]sk-[a-zA-Z0-9]{20,}['"]/, // OpenAI API keys
                  /['"]pk_live_[a-zA-Z0-9]{24,}['"]/, // Stripe keys
                  /['"]r[a-zA-Z0-9]{33}['"]/, // Reddit keys
                  /['"]xoxb-[a-zA-Z0-9\-]+['"]/, // Slack tokens
                  /['"]ghp_[a-zA-Z0-9]{36}['"]/, // GitHub tokens
                ];
                
                hardcodedPatterns.forEach((pattern, index) => {
                  const matches = content.match(pattern);
                  if (matches) {
                    results.hardcodedValues.push({
                      file: filePath,
                      type: ['OpenAI', 'Stripe', 'Reddit', 'Slack', 'GitHub'][index],
                      match: matches[0].substring(0, 20) + '...'
                    });
                  }
                });
                
                // 잠재적 누출 찾기
                const potentialLeaks = [
                  /console\.log.*process\.env/g,
                  /alert.*process\.env/g,
                  /document\.write.*process\.env/g
                ];
                
                potentialLeaks.forEach(pattern => {
                  const matches = content.match(pattern);
                  if (matches) {
                    results.potentialLeaks.push({
                      file: filePath,
                      matches: matches
                    });
                  }
                });
                
                // 설정 파일들
                if (item.includes('.env') || item.includes('config')) {
                  results.configFiles.push(filePath);
                }
                
              } catch (error) {
                // 파일 읽기 실패는 무시
              }
            }
            
            scanDirectory(dir);
            return results;
          }
          
          const results = analyzeEnvUsage('.');
          
          console.log('📊 환경변수 사용 분석 결과:');
          console.log(`  환경변수 참조: ${results.envReferences.length}개`);
          console.log(`  잠재적 누출: ${results.potentialLeaks.length}개`);
          console.log(`  하드코딩된 값: ${results.hardcodedValues.length}개`);
          console.log(`  설정 파일: ${results.configFiles.length}개`);
          
          if (results.potentialLeaks.length > 0) {
            console.log('\n⚠️ 잠재적 환경변수 누출:');
            results.potentialLeaks.forEach(leak => {
              console.log(`  ${leak.file}: ${leak.matches.join(', ')}`);
            });
          }
          
          if (results.hardcodedValues.length > 0) {
            console.log('\n🚨 하드코딩된 민감한 값들:');
            results.hardcodedValues.forEach(hard => {
              console.log(`  ${hard.file}: ${hard.type} - ${hard.match}`);
            });
          }
          
          fs.writeFileSync('env-analysis.json', JSON.stringify(results, null, 2));
          EOF
          
          node env-pattern-analyzer.js

      - name: 🧪 의존성 취약점 고급 분석
        run: |
          echo "🔍 의존성 취약점 고급 분석..."
          
          # npm audit 상세 분석
          npm audit --audit-level=low --json > npm-audit-detailed.json || true
          
          # 취약점 분석 스크립트
          cat > vulnerability-analyzer.js << 'EOF'
          const fs = require('fs');
          
          try {
            const auditData = JSON.parse(fs.readFileSync('npm-audit-detailed.json', 'utf8'));
            
            if (auditData.vulnerabilities) {
              const vulns = Object.entries(auditData.vulnerabilities);
              
              console.log(`📊 의존성 취약점 상세 분석:`);
              console.log(`  총 취약점: ${vulns.length}개`);
              
              const severityCount = { low: 0, moderate: 0, high: 0, critical: 0 };
              const categories = {};
              
              vulns.forEach(([name, vuln]) => {
                const severity = vuln.severity;
                severityCount[severity]++;
                
                const category = vuln.via?.[0]?.title?.split(' ')[0] || 'Unknown';
                categories[category] = (categories[category] || 0) + 1;
              });
              
              console.log(`\n📈 심각도별 분포:`);
              Object.entries(severityCount).forEach(([severity, count]) => {
                if (count > 0) {
                  console.log(`  ${severity}: ${count}개`);
                }
              });
              
              console.log(`\n🏷️ 카테고리별 분포:`);
              Object.entries(categories).slice(0, 5).forEach(([category, count]) => {
                console.log(`  ${category}: ${count}개`);
              });
              
              // 심각한 취약점들
              const criticalVulns = vulns.filter(([, vuln]) => 
                vuln.severity === 'critical' || vuln.severity === 'high'
              );
              
              if (criticalVulns.length > 0) {
                console.log(`\n🚨 긴급 처리 필요 (Critical/High):`);
                criticalVulns.slice(0, 5).forEach(([name, vuln]) => {
                  console.log(`  ${name}: ${vuln.severity} - ${vuln.via?.[0]?.title || 'No title'}`);
                });
              }
              
              // 권장사항
              const recommendations = [];
              if (severityCount.critical > 0) {
                recommendations.push('즉시 Critical 취약점 패치 필요');
              }
              if (severityCount.high > 3) {
                recommendations.push('High 취약점이 많음 - 순차적 패치 계획 수립');
              }
              if (vulns.length > 50) {
                recommendations.push('전체 의존성 정리 및 최신화 필요');
              }
              
              if (recommendations.length > 0) {
                console.log(`\n💡 권장사항:`);
                recommendations.forEach((rec, i) => {
                  console.log(`  ${i + 1}. ${rec}`);
                });
              }
              
            } else {
              console.log('✅ 발견된 취약점 없음');
            }
          } catch (error) {
            console.log('ℹ️ npm audit 데이터 분석 실패:', error.message);
          }
          EOF
          
          node vulnerability-analyzer.js

      - name: 📤 시크릿 스캔 결과 업로드
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: secrets-scan-results
          path: |
            gitleaks-report.json
            env-analysis.json
            npm-audit-detailed.json
          retention-days: 30

  # 코드 보안 정적 분석
  static-security-analysis:
    name: 📊 정적 보안 분석
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: 📥 코드 체크아웃
        uses: actions/checkout@v4

      - name: 🔧 Node.js 설정
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: 📦 보안 도구 설치
        run: |
          npm install --no-save eslint-plugin-security eslint-plugin-react-hooks @typescript-eslint/eslint-plugin
          
      - name: 🔍 ESLint 보안 규칙 스캔
        run: |
          # 보안 특화 ESLint 설정 생성
          cat > .eslintrc.security.json << 'EOF'
          {
            "extends": ["eslint:recommended"],
            "plugins": ["security", "react-hooks", "@typescript-eslint"],
            "parserOptions": {
              "ecmaVersion": 2021,
              "sourceType": "module",
              "ecmaFeatures": {
                "jsx": true
              }
            },
            "env": {
              "browser": true,
              "node": true,
              "es6": true
            },
            "rules": {
              "security/detect-object-injection": "error",
              "security/detect-non-literal-regexp": "error",
              "security/detect-buffer-noassert": "error",
              "security/detect-child-process": "error",
              "security/detect-disable-mustache-escape": "error",
              "security/detect-eval-with-expression": "error",
              "security/detect-no-csrf-before-method-override": "error",
              "security/detect-non-literal-fs-filename": "error",
              "security/detect-non-literal-require": "error",
              "security/detect-possible-timing-attacks": "error",
              "security/detect-pseudoRandomBytes": "error",
              "security/detect-unsafe-regex": "error",
              "no-eval": "error",
              "no-implied-eval": "error",
              "no-new-func": "error",
              "no-script-url": "error",
              "react-hooks/rules-of-hooks": "error",
              "react-hooks/exhaustive-deps": "warn"
            }
          }
          EOF
          
          # 보안 스캔 실행
          npx eslint . --config .eslintrc.security.json --ext .js,.jsx,.ts,.tsx --format json > eslint-security.json || true
          
          # 결과 분석
          cat > analyze-security-eslint.js << 'EOF'
          const fs = require('fs');
          
          try {
            const results = JSON.parse(fs.readFileSync('eslint-security.json', 'utf8'));
            
            let totalIssues = 0;
            const ruleStats = {};
            const severityStats = { error: 0, warning: 0 };
            
            results.forEach(file => {
              file.messages.forEach(message => {
                totalIssues++;
                const rule = message.ruleId || 'unknown';
                ruleStats[rule] = (ruleStats[rule] || 0) + 1;
                
                if (message.severity === 2) {
                  severityStats.error++;
                } else if (message.severity === 1) {
                  severityStats.warning++;
                }
              });
            });
            
            console.log('📊 ESLint 보안 스캔 결과:');
            console.log(`  총 이슈: ${totalIssues}개`);
            console.log(`  에러: ${severityStats.error}개`);
            console.log(`  경고: ${severityStats.warning}개`);
            
            if (totalIssues > 0) {
              console.log('\n🔝 상위 보안 규칙 위반:');
              const sortedRules = Object.entries(ruleStats)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 5);
                
              sortedRules.forEach(([rule, count]) => {
                console.log(`  ${rule}: ${count}개`);
              });
            }
            
            if (severityStats.error > 0) {
              console.log('\n🚨 즉시 수정 필요한 보안 이슈:');
              results.forEach(file => {
                const errors = file.messages.filter(m => m.severity === 2);
                if (errors.length > 0) {
                  console.log(`  ${file.filePath}:`);
                  errors.slice(0, 3).forEach(error => {
                    console.log(`    라인 ${error.line}: ${error.message} (${error.ruleId})`);
                  });
                }
              });
            }
            
          } catch (error) {
            console.log('ESLint 보안 스캔 결과 분석 실패:', error.message);
          }
          EOF
          
          node analyze-security-eslint.js

      - name: 🔒 TypeScript 타입 안전성 검증
        run: |
          echo "🔍 TypeScript 타입 안전성 보안 검증..."
          
          # 타입 안전성 검사
          npx tsc --noEmit --strict > ts-security.log 2>&1 || true
          
          # any 타입 사용 검사
          find . -name "*.ts" -o -name "*.tsx" | grep -v node_modules | xargs grep -n ": any" > any-types.log || true
          
          echo "📊 TypeScript 보안 검증 결과:"
          
          if [ -s ts-security.log ]; then
            error_count=$(wc -l < ts-security.log)
            echo "  타입 오류: ${error_count}개"
            
            if [ "$error_count" -gt 0 ]; then
              echo "\n⚠️ 주요 타입 오류들:"
              head -5 ts-security.log
            fi
          else
            echo "  ✅ 타입 오류 없음"
          fi
          
          if [ -s any-types.log ]; then
            any_count=$(wc -l < any-types.log)
            echo "  any 타입 사용: ${any_count}개"
            
            if [ "$any_count" -gt 10 ]; then
              echo "  ⚠️ any 타입 과다 사용 - 타입 안전성 위험"
            fi
          else
            echo "  ✅ any 타입 사용 없음"
          fi

      - name: 📤 정적 분석 결과 업로드
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: static-security-analysis
          path: |
            eslint-security.json
            ts-security.log
            any-types.log
          retention-days: 7

  # 보안 종합 리포트
  security-report:
    name: 📋 보안 종합 리포트
    runs-on: ubuntu-latest
    needs: [owasp-security, secrets-advanced-scan, static-security-analysis]
    if: always()
    
    steps:
      - name: 📥 아티팩트 다운로드
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: 📊 보안 종합 리포트 생성
        run: |
          echo "# 🛡️ dduksangLAB 고급 보안 스캔 리포트" > security-report.md
          echo "" >> security-report.md
          echo "생성 시간: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> security-report.md
          echo "커밋: ${{ github.sha }}" >> security-report.md
          echo "브랜치: ${{ github.ref_name }}" >> security-report.md
          echo "" >> security-report.md
          
          # 보안 스캔 결과 요약
          echo "## 📊 보안 스캔 결과 요약" >> security-report.md
          echo "| 보안 영역 | 상태 | 설명 |" >> security-report.md
          echo "|----------|------|------|" >> security-report.md
          echo "| OWASP Top 10 | ${{ needs.owasp-security.result == 'success' && '✅ 통과' || '❌ 위험' }} | 웹 애플리케이션 보안 기준 |" >> security-report.md
          echo "| 시크릿 스캔 | ${{ needs.secrets-advanced-scan.result == 'success' && '✅ 안전' || '❌ 누출' }} | 환경변수 및 하드코딩 검사 |" >> security-report.md
          echo "| 정적 분석 | ${{ needs.static-security-analysis.result == 'success' && '✅ 통과' || '❌ 문제' }} | 코드 레벨 보안 분석 |" >> security-report.md
          echo "" >> security-report.md
          
          # OWASP 분석 결과
          echo "## 🔍 OWASP Top 10 분석" >> security-report.md
          if [ -f "artifacts/owasp-security-results/owasp-results.json" ]; then
            echo "### 주요 발견사항" >> security-report.md
            echo "- A01: Broken Access Control 검증 완료" >> security-report.md
            echo "- A02: Cryptographic Failures 분석 완료" >> security-report.md
            echo "- A03: Injection 방어 테스트 완료" >> security-report.md
            echo "- A04: Insecure Design 보안 헤더 검증" >> security-report.md
            echo "- A05: Security Misconfiguration 설정 검증" >> security-report.md
          else
            echo "- OWASP 스캔 데이터 없음" >> security-report.md
          fi
          echo "" >> security-report.md
          
          # 시크릿 스캔 결과
          echo "## 🔐 시크릿 및 환경변수 검사" >> security-report.md
          if [ -f "artifacts/secrets-scan-results/env-analysis.json" ]; then
            echo "### 환경변수 사용 현황" >> security-report.md
            env_refs=$(jq -r '.envReferences | length' artifacts/secrets-scan-results/env-analysis.json 2>/dev/null || echo "0")
            leaks=$(jq -r '.potentialLeaks | length' artifacts/secrets-scan-results/env-analysis.json 2>/dev/null || echo "0")
            hardcoded=$(jq -r '.hardcodedValues | length' artifacts/secrets-scan-results/env-analysis.json 2>/dev/null || echo "0")
            
            echo "- 환경변수 참조: ${env_refs}개" >> security-report.md
            echo "- 잠재적 누출: ${leaks}개" >> security-report.md
            echo "- 하드코딩된 값: ${hardcoded}개" >> security-report.md
            
            if [ "$leaks" -gt 0 ] || [ "$hardcoded" -gt 0 ]; then
              echo "- ⚠️ 즉시 검토 필요" >> security-report.md
            fi
          else
            echo "- 시크릿 스캔 데이터 없음" >> security-report.md
          fi
          echo "" >> security-report.md
          
          # 권장사항
          echo "## 💡 보안 강화 권장사항" >> security-report.md
          echo "### 즉시 조치 필요" >> security-report.md
          echo "1. **Critical/High 취약점**: 즉시 패치 적용" >> security-report.md
          echo "2. **하드코딩된 시크릿**: 환경변수로 전환" >> security-report.md
          echo "3. **보안 헤더**: 누락된 보안 헤더 추가" >> security-report.md
          echo "" >> security-report.md
          echo "### 지속적 개선" >> security-report.md
          echo "1. **의존성 관리**: 정기적 업데이트 및 취약점 모니터링" >> security-report.md
          echo "2. **코드 리뷰**: 보안 중심 코드 리뷰 프로세스" >> security-report.md
          echo "3. **보안 테스트**: CI/CD 파이프라인 보안 테스트 통합" >> security-report.md
          echo "4. **모니터링**: 런타임 보안 모니터링 구축" >> security-report.md
          echo "5. **교육**: 개발팀 보안 교육 정기 실시" >> security-report.md
          echo "" >> security-report.md
          
          # 컴플라이언스 체크리스트
          echo "## ✅ 보안 컴플라이언스 체크리스트" >> security-report.md
          echo "- [ ] OWASP Top 10 대응 완료" >> security-report.md
          echo "- [ ] 모든 시크릿 환경변수화" >> security-report.md
          echo "- [ ] CSP 헤더 적용" >> security-report.md
          echo "- [ ] HTTPS 강제 적용" >> security-report.md
          echo "- [ ] 입력값 검증 강화" >> security-report.md
          echo "- [ ] 에러 처리 보안 강화" >> security-report.md
          echo "- [ ] 의존성 취약점 제로화" >> security-report.md
          echo "- [ ] 정기 보안 스캔 자동화" >> security-report.md
          
          cat security-report.md >> $GITHUB_STEP_SUMMARY

      - name: 📤 보안 종합 리포트 업로드
        uses: actions/upload-artifact@v4
        with:
          name: security-comprehensive-report-${{ github.run_id }}
          path: security-report.md
          retention-days: 90