#!/usr/bin/env node

/**
 * Security 자동화 에이전트 - 의존성 및 취약점 검사
 * 
 * 이 스크립트는 프로젝트의 보안 상태를 종합적으로 분석하고
 * 취약점을 자동으로 감지하여 보고서를 생성합니다.
 * 
 * 주요 기능:
 * - NPM 패키지 취약점 스캔
 * - 하드코딩된 시크릿 검사
 * - 보안 헤더 검증
 * - 의존성 라이선스 검토
 * - OWASP 보안 가이드라인 준수 검사
 * - 자동 취약점 수정 제안
 */

const { exec, execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const https = require('https');
const { promisify } = require('util');

const execAsync = promisify(exec);

class VulnerabilityScanner {
  constructor(options = {}) {
    this.options = {
      outputFormat: options.outputFormat || 'console', // console, json, sarif
      severity: options.severity || ['critical', 'high', 'moderate'],
      skipPatches: options.skipPatches || false,
      includeDevDeps: options.includeDevDeps || false,
      ...options
    };
    
    this.vulnerabilities = {
      npm: [],
      secrets: [],
      dependencies: [],
      licenses: [],
      headers: [],
      general: []
    };
    
    this.stats = {
      totalIssues: 0,
      critical: 0,
      high: 0,
      moderate: 0,
      low: 0,
      info: 0
    };
  }

  // 로그 유틸리티
  log(level, message, data = null) {
    const timestamp = new Date().toISOString();
    const colors = {
      error: '\x1b[31m',
      warn: '\x1b[33m',
      info: '\x1b[36m',
      success: '\x1b[32m',
      debug: '\x1b[37m'
    };
    
    const color = colors[level] || colors.info;
    const prefix = {
      error: '🚨',
      warn: '⚠️ ',
      info: 'ℹ️ ',
      success: '✅',
      debug: '🔧'
    }[level] || 'ℹ️ ';
    
    console.log(`${color}[${timestamp}] ${prefix} ${message}\x1b[0m`);
    
    if (data && process.env.DEBUG) {
      console.log(`${color}   ${JSON.stringify(data, null, 2)}\x1b[0m`);
    }
  }

  // NPM Audit 실행
  async runNpmAudit() {
    this.log('info', '🔍 NPM 취약점 스캔 시작...');
    
    try {
      const auditCommand = `npm audit ${this.options.includeDevDeps ? '' : '--production'} --json`;
      const { stdout } = await execAsync(auditCommand);
      const auditResult = JSON.parse(stdout);
      
      if (auditResult.vulnerabilities) {
        Object.keys(auditResult.vulnerabilities).forEach(packageName => {
          const vuln = auditResult.vulnerabilities[packageName];
          
          if (this.options.severity.includes(vuln.severity)) {
            this.vulnerabilities.npm.push({
              package: packageName,
              severity: vuln.severity,
              title: vuln.title,
              url: vuln.url,
              via: vuln.via,
              fixAvailable: vuln.fixAvailable,
              timestamp: new Date().toISOString()
            });
            
            this.updateStats(vuln.severity);
          }
        });
      }
      
      this.log('success', `NPM 스캔 완료: ${this.vulnerabilities.npm.length}개 취약점 발견`);
      
      return auditResult;
      
    } catch (error) {
      this.log('error', 'NPM 감사 실행 실패', { error: error.message });
      
      // 수동 패키지 확인 시도
      try {
        await this.manualPackageCheck();
      } catch (manualError) {
        this.log('error', '수동 패키지 확인도 실패', manualError);
      }
      
      return null;
    }
  }

  // 수동 패키지 취약점 확인
  async manualPackageCheck() {
    this.log('debug', '📦 수동 패키지 취약점 확인 시작');
    
    const packageJsonPath = path.join(process.cwd(), 'package.json');
    
    if (!fs.existsSync(packageJsonPath)) {
      throw new Error('package.json 파일을 찾을 수 없습니다');
    }
    
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    const dependencies = {
      ...packageJson.dependencies,
      ...(this.options.includeDevDeps ? packageJson.devDependencies : {})
    };
    
    // 알려진 취약한 패키지 확인
    const knownVulnerablePackages = [
      { name: 'lodash', version: '<4.17.21', severity: 'high' },
      { name: 'axios', version: '<0.21.2', severity: 'moderate' },
      { name: 'moment', version: '<2.29.2', severity: 'moderate' },
      { name: 'node-fetch', version: '<2.6.7', severity: 'high' }
    ];
    
    Object.keys(dependencies).forEach(packageName => {
      const vulnerablePackage = knownVulnerablePackages.find(vp => vp.name === packageName);
      
      if (vulnerablePackage) {
        this.vulnerabilities.npm.push({
          package: packageName,
          version: dependencies[packageName],
          severity: vulnerablePackage.severity,
          title: `알려진 취약한 버전 감지: ${packageName}`,
          recommendation: `최신 버전으로 업데이트 필요`,
          timestamp: new Date().toISOString()
        });
        
        this.updateStats(vulnerablePackage.severity);
      }
    });
  }

  // 하드코딩된 시크릿 검사
  async scanHardcodedSecrets() {
    this.log('info', '🔐 하드코딩된 시크릿 검사 시작...');
    
    const secretPatterns = [
      {
        name: 'API Keys',
        pattern: /(?:api[_-]?key|apikey)\s*[:=]\s*['"]([^'"]{20,})['"]/gi,
        severity: 'critical'
      },
      {
        name: 'Database URLs',
        pattern: /(?:database[_-]?url|db[_-]?url)\s*[:=]\s*['"]([^'"]+)['"]/gi,
        severity: 'critical'
      },
      {
        name: 'JWT Secrets',
        pattern: /(?:jwt[_-]?secret|secret[_-]?key)\s*[:=]\s*['"]([^'"]{16,})['"]/gi,
        severity: 'high'
      },
      {
        name: 'Passwords',
        pattern: /(?:password|pwd)\s*[:=]\s*['"]([^'"]{4,})['"]/gi,
        severity: 'high'
      },
      {
        name: 'Private Keys',
        pattern: /-----BEGIN (?:RSA )?PRIVATE KEY-----/gi,
        severity: 'critical'
      },
      {
        name: 'Generic Secrets',
        pattern: /(?:secret|token|key)\s*[:=]\s*['"][a-zA-Z0-9+/=]{20,}['"]/gi,
        severity: 'moderate'
      }
    ];
    
    const excludePatterns = [
      /node_modules/,
      /\.git/,
      /\.next/,
      /dist/,
      /build/,
      /coverage/,
      /\.env\.example/,
      /README\.md/
    ];
    
    const scanResults = [];
    
    try {
      // 소스 코드 파일 검색
      const { stdout: findResult } = await execAsync(
        'find . -type f \\( -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" -o -name "*.json" -o -name "*.env*" \\) -not -path "./node_modules/*" -not -path "./.next/*" -not -path "./.git/*"'
      );
      
      const files = findResult.trim().split('\n').filter(file => file);
      
      for (const file of files) {
        // 제외 패턴 확인
        if (excludePatterns.some(pattern => pattern.test(file))) {
          continue;
        }
        
        try {
          const content = fs.readFileSync(file, 'utf8');
          
          secretPatterns.forEach(pattern => {
            let match;
            while ((match = pattern.pattern.exec(content)) !== null) {
              // 실제 시크릿인지 확인 (테스트 값 제외)
              const value = match[1] || match[0];
              if (this.isLikelySecret(value)) {
                const lineNumber = content.substring(0, match.index).split('\n').length;
                
                scanResults.push({
                  type: pattern.name,
                  file: file,
                  line: lineNumber,
                  severity: pattern.severity,
                  preview: this.maskSecret(match[0]),
                  timestamp: new Date().toISOString()
                });
                
                this.updateStats(pattern.severity);
              }
            }
          });
          
        } catch (readError) {
          this.log('debug', `파일 읽기 실패: ${file}`, readError);
        }
      }
      
      this.vulnerabilities.secrets = scanResults;
      this.log('success', `시크릿 스캔 완료: ${scanResults.length}개 잠재적 시크릿 발견`);
      
      return scanResults;
      
    } catch (error) {
      this.log('error', '시크릿 스캔 실패', error);
      return [];
    }
  }

  // 시크릿 가능성 판단
  isLikelySecret(value) {
    // 테스트나 더미 값 제외
    const dummyValues = [
      'test', 'example', 'dummy', 'placeholder', 'your-key-here',
      '123456', 'password', 'secret', 'changeme', 'localhost'
    ];
    
    const lowerValue = value.toLowerCase();
    
    // 더미 값이면 false
    if (dummyValues.some(dummy => lowerValue.includes(dummy))) {
      return false;
    }
    
    // 길이가 충분하고 복잡한 문자열이면 true
    if (value.length >= 20 && /[A-Za-z]/.test(value) && /[0-9]/.test(value)) {
      return true;
    }
    
    // 특정 패턴 (API 키 형태)
    if (/^[A-Za-z0-9+/=]{32,}$/.test(value) || /^[A-Za-z0-9_-]{20,}$/.test(value)) {
      return true;
    }
    
    return false;
  }

  // 시크릿 마스킹
  maskSecret(secret) {
    if (secret.length <= 8) {
      return '*'.repeat(secret.length);
    }
    
    const start = secret.substring(0, 3);
    const end = secret.substring(secret.length - 3);
    const middle = '*'.repeat(Math.min(secret.length - 6, 20));
    
    return `${start}${middle}${end}`;
  }

  // 의존성 라이선스 검사
  async checkLicenses() {
    this.log('info', '📜 의존성 라이선스 검사 시작...');
    
    try {
      // license-checker 설치 여부 확인
      try {
        execSync('npm list license-checker --depth=0', { stdio: 'ignore' });
      } catch (error) {
        this.log('info', 'license-checker 설치 중...');
        execSync('npm install --no-save license-checker', { stdio: 'inherit' });
      }
      
      // 라이선스 정보 수집
      const { stdout } = await execAsync('npx license-checker --json --production --excludePrivatePackages');
      const licenses = JSON.parse(stdout);
      
      // 문제가 될 수 있는 라이선스
      const problematicLicenses = [
        'GPL-3.0', 'GPL-2.0', 'GPL-1.0',
        'AGPL-3.0', 'AGPL-1.0',
        'LGPL-3.0', 'LGPL-2.1',
        'CPAL-1.0', 'EPL-1.0', 'EPL-2.0',
        'EUPL-1.1', 'EUPL-1.2'
      ];
      
      const licenseIssues = [];
      
      Object.keys(licenses).forEach(packageName => {
        const licenseInfo = licenses[packageName];
        const license = licenseInfo.licenses;
        
        if (problematicLicenses.some(problematic => 
          license && license.toUpperCase().includes(problematic.toUpperCase())
        )) {
          licenseIssues.push({
            package: packageName,
            license: license,
            severity: 'moderate',
            issue: '상업적 사용에 제한이 있을 수 있는 라이선스',
            timestamp: new Date().toISOString()
          });
          
          this.updateStats('moderate');
        }
        
        // 라이선스 누락 체크
        if (!license || license === 'UNKNOWN') {
          licenseIssues.push({
            package: packageName,
            license: 'UNKNOWN',
            severity: 'low',
            issue: '라이선스 정보 누락',
            timestamp: new Date().toISOString()
          });
          
          this.updateStats('low');
        }
      });
      
      this.vulnerabilities.licenses = licenseIssues;
      this.log('success', `라이선스 검사 완료: ${licenseIssues.length}개 이슈 발견`);
      
      return licenseIssues;
      
    } catch (error) {
      this.log('error', '라이선스 검사 실패', error);
      return [];
    }
  }

  // 보안 헤더 검증 (배포된 사이트)
  async checkSecurityHeaders() {
    this.log('info', '🛡️ 보안 헤더 검증 시작...');
    
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://dduksang.com';
    
    if (!baseUrl || baseUrl.includes('localhost')) {
      this.log('info', '로컬 환경 - 보안 헤더 검사 스킵');
      return [];
    }
    
    try {
      const response = await this.makeHttpRequest(baseUrl);
      const headers = response.headers;
      
      const securityHeaders = [
        {
          name: 'Strict-Transport-Security',
          required: true,
          severity: 'high',
          description: 'HTTPS 강제를 위한 HSTS 헤더'
        },
        {
          name: 'X-Content-Type-Options',
          required: true,
          severity: 'moderate',
          expectedValue: 'nosniff',
          description: 'MIME 타입 스니핑 방지'
        },
        {
          name: 'X-Frame-Options',
          required: true,
          severity: 'moderate',
          expectedValue: ['DENY', 'SAMEORIGIN'],
          description: 'Clickjacking 공격 방지'
        },
        {
          name: 'X-XSS-Protection',
          required: false,
          severity: 'low',
          expectedValue: '1; mode=block',
          description: 'XSS 필터링 활성화'
        },
        {
          name: 'Content-Security-Policy',
          required: true,
          severity: 'high',
          description: 'CSP를 통한 XSS 및 데이터 주입 공격 방지'
        },
        {
          name: 'Referrer-Policy',
          required: false,
          severity: 'low',
          expectedValue: 'strict-origin-when-cross-origin',
          description: 'Referrer 정보 제어'
        }
      ];
      
      const headerIssues = [];
      
      securityHeaders.forEach(securityHeader => {
        const headerValue = headers[securityHeader.name.toLowerCase()];
        
        if (!headerValue) {
          if (securityHeader.required) {
            headerIssues.push({
              type: 'missing_header',
              header: securityHeader.name,
              severity: securityHeader.severity,
              description: `필수 보안 헤더 누락: ${securityHeader.description}`,
              recommendation: `${securityHeader.name} 헤더 추가 필요`,
              timestamp: new Date().toISOString()
            });
            
            this.updateStats(securityHeader.severity);
          }
        } else if (securityHeader.expectedValue) {
          const expectedValues = Array.isArray(securityHeader.expectedValue) 
            ? securityHeader.expectedValue 
            : [securityHeader.expectedValue];
          
          if (!expectedValues.some(expected => 
            headerValue.toLowerCase().includes(expected.toLowerCase())
          )) {
            headerIssues.push({
              type: 'weak_header',
              header: securityHeader.name,
              currentValue: headerValue,
              expectedValue: securityHeader.expectedValue,
              severity: 'low',
              description: `보안 헤더 값이 권장사항과 다름`,
              timestamp: new Date().toISOString()
            });
            
            this.updateStats('low');
          }
        }
      });
      
      this.vulnerabilities.headers = headerIssues;
      this.log('success', `보안 헤더 검증 완료: ${headerIssues.length}개 이슈 발견`);
      
      return headerIssues;
      
    } catch (error) {
      this.log('error', '보안 헤더 검증 실패', error);
      return [];
    }
  }

  // HTTP 요청 유틸리티
  makeHttpRequest(url) {
    return new Promise((resolve, reject) => {
      https.get(url, (response) => {
        let data = '';
        
        response.on('data', chunk => {
          data += chunk;
        });
        
        response.on('end', () => {
          resolve({
            statusCode: response.statusCode,
            headers: response.headers,
            data: data
          });
        });
      }).on('error', reject);
    });
  }

  // 통계 업데이트
  updateStats(severity) {
    this.stats.totalIssues++;
    this.stats[severity] = (this.stats[severity] || 0) + 1;
  }

  // 종합 보안 스캔 실행
  async runFullScan() {
    this.log('info', '🚀 종합 보안 스캔 시작...');
    const scanStart = Date.now();
    
    try {
      // 병렬로 모든 스캔 실행
      await Promise.all([
        this.runNpmAudit(),
        this.scanHardcodedSecrets(),
        this.checkLicenses(),
        this.checkSecurityHeaders()
      ]);
      
      const scanDuration = Date.now() - scanStart;
      this.log('success', `보안 스캔 완료 (${scanDuration}ms)`);
      
      // 결과 분석 및 리포트 생성
      return this.generateSecurityReport();
      
    } catch (error) {
      this.log('error', '보안 스캔 실행 중 오류 발생', error);
      throw error;
    }
  }

  // 보안 리포트 생성
  generateSecurityReport() {
    this.log('info', '📊 보안 리포트 생성 중...');
    
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalIssues: this.stats.totalIssues,
        critical: this.stats.critical || 0,
        high: this.stats.high || 0,
        moderate: this.stats.moderate || 0,
        low: this.stats.low || 0,
        info: this.stats.info || 0
      },
      vulnerabilities: this.vulnerabilities,
      recommendations: this.generateRecommendations()
    };
    
    // 콘솔 출력
    this.printSecurityReport(report);
    
    // 파일로 저장
    if (this.options.outputFormat === 'json') {
      this.saveJsonReport(report);
    }
    
    // SARIF 형식 (GitHub Security Tab용)
    if (this.options.outputFormat === 'sarif') {
      this.saveSarifReport(report);
    }
    
    return report;
  }

  // 권장사항 생성
  generateRecommendations() {
    const recommendations = [];
    
    // NPM 취약점
    if (this.vulnerabilities.npm.length > 0) {
      recommendations.push({
        category: 'dependencies',
        priority: 'high',
        action: 'npm audit fix 실행으로 자동 수정 가능한 취약점 해결',
        details: `${this.vulnerabilities.npm.length}개의 NPM 취약점이 발견되었습니다.`
      });
    }
    
    // 하드코딩된 시크릿
    if (this.vulnerabilities.secrets.length > 0) {
      recommendations.push({
        category: 'secrets',
        priority: 'critical',
        action: '하드코딩된 시크릿을 환경변수로 이동',
        details: `${this.vulnerabilities.secrets.length}개의 잠재적 시크릿이 발견되었습니다.`
      });
    }
    
    // 라이선스 이슈
    if (this.vulnerabilities.licenses.length > 0) {
      recommendations.push({
        category: 'licensing',
        priority: 'moderate',
        action: '문제가 될 수 있는 라이선스를 가진 패키지 검토 및 대체',
        details: `${this.vulnerabilities.licenses.length}개의 라이선스 이슈가 발견되었습니다.`
      });
    }
    
    // 보안 헤더
    if (this.vulnerabilities.headers.length > 0) {
      recommendations.push({
        category: 'headers',
        priority: 'high',
        action: 'Next.js 설정에 보안 헤더 추가',
        details: `${this.vulnerabilities.headers.length}개의 보안 헤더 이슈가 발견되었습니다.`
      });
    }
    
    return recommendations;
  }

  // 콘솔 리포트 출력
  printSecurityReport(report) {
    console.log('\n' + '='.repeat(60));
    this.log('info', '🛡️ 보안 스캔 결과 리포트');
    console.log('='.repeat(60));
    
    // 요약
    console.log(`\n📊 요약:`);
    console.log(`  총 이슈: ${report.summary.totalIssues}개`);
    console.log(`  🚨 Critical: ${report.summary.critical}개`);
    console.log(`  ⚠️  High: ${report.summary.high}개`);
    console.log(`  📋 Moderate: ${report.summary.moderate}개`);
    console.log(`  ℹ️  Low: ${report.summary.low}개`);
    
    // 카테고리별 세부사항
    if (report.vulnerabilities.npm.length > 0) {
      console.log(`\n📦 NPM 취약점 (${report.vulnerabilities.npm.length}개):`);
      report.vulnerabilities.npm.slice(0, 5).forEach(vuln => {
        console.log(`  • ${vuln.package} (${vuln.severity}): ${vuln.title}`);
      });
      if (report.vulnerabilities.npm.length > 5) {
        console.log(`  ... 및 ${report.vulnerabilities.npm.length - 5}개 추가`);
      }
    }
    
    if (report.vulnerabilities.secrets.length > 0) {
      console.log(`\n🔐 시크릿 검사 (${report.vulnerabilities.secrets.length}개):`);
      report.vulnerabilities.secrets.slice(0, 3).forEach(secret => {
        console.log(`  • ${secret.file}:${secret.line} (${secret.severity}): ${secret.type}`);
      });
      if (report.vulnerabilities.secrets.length > 3) {
        console.log(`  ... 및 ${report.vulnerabilities.secrets.length - 3}개 추가`);
      }
    }
    
    // 권장사항
    if (report.recommendations.length > 0) {
      console.log(`\n💡 권장사항:`);
      report.recommendations.forEach((rec, index) => {
        console.log(`  ${index + 1}. [${rec.priority.toUpperCase()}] ${rec.action}`);
        console.log(`     ${rec.details}`);
      });
    }
    
    // 전체 결과 평가
    const riskLevel = this.assessOverallRisk(report.summary);
    console.log(`\n🎯 전체 위험도: ${riskLevel.level} (${riskLevel.description})`);
    
    console.log('='.repeat(60));
  }

  // 전체 위험도 평가
  assessOverallRisk(summary) {
    if (summary.critical > 0) {
      return {
        level: '🚨 Critical',
        description: '즉시 조치가 필요한 심각한 보안 이슈 존재'
      };
    }
    
    if (summary.high >= 3) {
      return {
        level: '🔴 High',
        description: '여러 높은 위험도 이슈로 인한 높은 보안 위험'
      };
    }
    
    if (summary.high > 0 || summary.moderate >= 5) {
      return {
        level: '🟡 Moderate',
        description: '보안 이슈가 있으나 관리 가능한 수준'
      };
    }
    
    if (summary.moderate > 0 || summary.low >= 10) {
      return {
        level: '🟢 Low',
        description: '경미한 보안 이슈들이 있으나 양호한 상태'
      };
    }
    
    return {
      level: '✅ Excellent',
      description: '보안 이슈가 발견되지 않았습니다'
    };
  }

  // JSON 리포트 저장
  saveJsonReport(report) {
    const filename = `security-report-${new Date().toISOString().split('T')[0]}.json`;
    const filepath = path.join(process.cwd(), 'security-reports', filename);
    
    try {
      // 디렉토리 생성
      const dir = path.dirname(filepath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      
      fs.writeFileSync(filepath, JSON.stringify(report, null, 2));
      this.log('success', `JSON 리포트 저장됨: ${filepath}`);
    } catch (error) {
      this.log('error', 'JSON 리포트 저장 실패', error);
    }
  }

  // SARIF 리포트 저장 (GitHub Security Tab용)
  saveSarifReport(report) {
    const sarif = {
      version: '2.1.0',
      $schema: 'https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0.json',
      runs: [{
        tool: {
          driver: {
            name: 'dduksangLAB Security Scanner',
            version: '1.0.0',
            informationUri: 'https://github.com/your-repo/security-scanner'
          }
        },
        results: this.convertToSarifResults(report)
      }]
    };
    
    const filename = `security-report-${new Date().toISOString().split('T')[0]}.sarif`;
    const filepath = path.join(process.cwd(), 'security-reports', filename);
    
    try {
      const dir = path.dirname(filepath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      
      fs.writeFileSync(filepath, JSON.stringify(sarif, null, 2));
      this.log('success', `SARIF 리포트 저장됨: ${filepath}`);
    } catch (error) {
      this.log('error', 'SARIF 리포트 저장 실패', error);
    }
  }

  // SARIF 형식으로 변환
  convertToSarifResults(report) {
    const results = [];
    
    // NPM 취약점
    report.vulnerabilities.npm.forEach(vuln => {
      results.push({
        ruleId: 'npm-vulnerability',
        level: this.mapSeverityToSarif(vuln.severity),
        message: {
          text: `NPM 취약점: ${vuln.title} in ${vuln.package}`
        },
        properties: {
          package: vuln.package,
          severity: vuln.severity
        }
      });
    });
    
    // 하드코딩된 시크릿
    report.vulnerabilities.secrets.forEach(secret => {
      results.push({
        ruleId: 'hardcoded-secret',
        level: this.mapSeverityToSarif(secret.severity),
        message: {
          text: `하드코딩된 시크릿 의심: ${secret.type}`
        },
        locations: [{
          physicalLocation: {
            artifactLocation: {
              uri: secret.file
            },
            region: {
              startLine: secret.line
            }
          }
        }],
        properties: {
          type: secret.type,
          severity: secret.severity
        }
      });
    });
    
    return results;
  }

  // 심각도를 SARIF 레벨로 매핑
  mapSeverityToSarif(severity) {
    const mapping = {
      critical: 'error',
      high: 'error',
      moderate: 'warning',
      low: 'note',
      info: 'note'
    };
    
    return mapping[severity] || 'note';
  }
}

// CLI 실행 처리
async function main() {
  const args = process.argv.slice(2);
  
  const options = {
    outputFormat: args.includes('--json') ? 'json' : args.includes('--sarif') ? 'sarif' : 'console',
    severity: args.includes('--all-severity') ? ['critical', 'high', 'moderate', 'low', 'info'] : ['critical', 'high', 'moderate'],
    includeDevDeps: args.includes('--include-dev'),
    skipPatches: args.includes('--skip-patches')
  };
  
  const scanner = new VulnerabilityScanner(options);
  
  try {
    const report = await scanner.runFullScan();
    
    // CI/CD에서 사용 시 종료 코드 설정
    if (process.env.CI === 'true') {
      const criticalIssues = report.summary.critical || 0;
      const highIssues = report.summary.high || 0;
      
      if (criticalIssues > 0) {
        console.log(`\n❌ Critical 이슈 ${criticalIssues}개로 인해 빌드 실패`);
        process.exit(1);
      } else if (highIssues > 3) {
        console.log(`\n⚠️ High 이슈 ${highIssues}개가 임계값을 초과했습니다`);
        process.exit(1);
      }
    }
    
    console.log('\n✅ 보안 스캔 완료');
    process.exit(0);
    
  } catch (error) {
    console.error('❌ 보안 스캔 실행 중 오류:', error);
    process.exit(1);
  }
}

// 스크립트 직접 실행시에만 main 함수 호출
if (require.main === module) {
  main();
}

module.exports = VulnerabilityScanner;