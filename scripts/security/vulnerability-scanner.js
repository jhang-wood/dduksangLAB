#!/usr/bin/env node

/**
 * Security ìë™í™” ì—ì´ì „íŠ¸ - ì˜ì¡´ì„± ë° ì·¨ì•½ì  ê²€ì‚¬
 * 
 * ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” í”„ë¡œì íŠ¸ì˜ ë³´ì•ˆ ìƒíƒœë¥¼ ì¢…í•©ì ìœ¼ë¡œ ë¶„ì„í•˜ê³ 
 * ì·¨ì•½ì ì„ ìë™ìœ¼ë¡œ ê°ì§€í•˜ì—¬ ë³´ê³ ì„œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 * 
 * ì£¼ìš” ê¸°ëŠ¥:
 * - NPM íŒ¨í‚¤ì§€ ì·¨ì•½ì  ìŠ¤ìº”
 * - í•˜ë“œì½”ë”©ëœ ì‹œí¬ë¦¿ ê²€ì‚¬
 * - ë³´ì•ˆ í—¤ë” ê²€ì¦
 * - ì˜ì¡´ì„± ë¼ì´ì„ ìŠ¤ ê²€í† 
 * - OWASP ë³´ì•ˆ ê°€ì´ë“œë¼ì¸ ì¤€ìˆ˜ ê²€ì‚¬
 * - ìë™ ì·¨ì•½ì  ìˆ˜ì • ì œì•ˆ
 */

const { exec, execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const https = require('https');
const { promisify } = require('util');

const execAsync = promisify(exec);

class VulnerabilityScanner {
  constructor(options = {}) {
    this.options = {
      outputFormat: options.outputFormat || 'console', // console, json, sarif
      severity: options.severity || ['critical', 'high', 'moderate'],
      skipPatches: options.skipPatches || false,
      includeDevDeps: options.includeDevDeps || false,
      ...options
    };
    
    this.vulnerabilities = {
      npm: [],
      secrets: [],
      dependencies: [],
      licenses: [],
      headers: [],
      general: []
    };
    
    this.stats = {
      totalIssues: 0,
      critical: 0,
      high: 0,
      moderate: 0,
      low: 0,
      info: 0
    };
  }

  // ë¡œê·¸ ìœ í‹¸ë¦¬í‹°
  log(level, message, data = null) {
    const timestamp = new Date().toISOString();
    const colors = {
      error: '\x1b[31m',
      warn: '\x1b[33m',
      info: '\x1b[36m',
      success: '\x1b[32m',
      debug: '\x1b[37m'
    };
    
    const color = colors[level] || colors.info;
    const prefix = {
      error: 'ğŸš¨',
      warn: 'âš ï¸ ',
      info: 'â„¹ï¸ ',
      success: 'âœ…',
      debug: 'ğŸ”§'
    }[level] || 'â„¹ï¸ ';
    
    console.log(`${color}[${timestamp}] ${prefix} ${message}\x1b[0m`);
    
    if (data && process.env.DEBUG) {
      console.log(`${color}   ${JSON.stringify(data, null, 2)}\x1b[0m`);
    }
  }

  // NPM Audit ì‹¤í–‰
  async runNpmAudit() {
    this.log('info', 'ğŸ” NPM ì·¨ì•½ì  ìŠ¤ìº” ì‹œì‘...');
    
    try {
      const auditCommand = `npm audit ${this.options.includeDevDeps ? '' : '--production'} --json`;
      const { stdout } = await execAsync(auditCommand);
      const auditResult = JSON.parse(stdout);
      
      if (auditResult.vulnerabilities) {
        Object.keys(auditResult.vulnerabilities).forEach(packageName => {
          const vuln = auditResult.vulnerabilities[packageName];
          
          if (this.options.severity.includes(vuln.severity)) {
            this.vulnerabilities.npm.push({
              package: packageName,
              severity: vuln.severity,
              title: vuln.title,
              url: vuln.url,
              via: vuln.via,
              fixAvailable: vuln.fixAvailable,
              timestamp: new Date().toISOString()
            });
            
            this.updateStats(vuln.severity);
          }
        });
      }
      
      this.log('success', `NPM ìŠ¤ìº” ì™„ë£Œ: ${this.vulnerabilities.npm.length}ê°œ ì·¨ì•½ì  ë°œê²¬`);
      
      return auditResult;
      
    } catch (error) {
      this.log('error', 'NPM ê°ì‚¬ ì‹¤í–‰ ì‹¤íŒ¨', { error: error.message });
      
      // ìˆ˜ë™ íŒ¨í‚¤ì§€ í™•ì¸ ì‹œë„
      try {
        await this.manualPackageCheck();
      } catch (manualError) {
        this.log('error', 'ìˆ˜ë™ íŒ¨í‚¤ì§€ í™•ì¸ë„ ì‹¤íŒ¨', manualError);
      }
      
      return null;
    }
  }

  // ìˆ˜ë™ íŒ¨í‚¤ì§€ ì·¨ì•½ì  í™•ì¸
  async manualPackageCheck() {
    this.log('debug', 'ğŸ“¦ ìˆ˜ë™ íŒ¨í‚¤ì§€ ì·¨ì•½ì  í™•ì¸ ì‹œì‘');
    
    const packageJsonPath = path.join(process.cwd(), 'package.json');
    
    if (!fs.existsSync(packageJsonPath)) {
      throw new Error('package.json íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
    }
    
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    const dependencies = {
      ...packageJson.dependencies,
      ...(this.options.includeDevDeps ? packageJson.devDependencies : {})
    };
    
    // ì•Œë ¤ì§„ ì·¨ì•½í•œ íŒ¨í‚¤ì§€ í™•ì¸
    const knownVulnerablePackages = [
      { name: 'lodash', version: '<4.17.21', severity: 'high' },
      { name: 'axios', version: '<0.21.2', severity: 'moderate' },
      { name: 'moment', version: '<2.29.2', severity: 'moderate' },
      { name: 'node-fetch', version: '<2.6.7', severity: 'high' }
    ];
    
    Object.keys(dependencies).forEach(packageName => {
      const vulnerablePackage = knownVulnerablePackages.find(vp => vp.name === packageName);
      
      if (vulnerablePackage) {
        this.vulnerabilities.npm.push({
          package: packageName,
          version: dependencies[packageName],
          severity: vulnerablePackage.severity,
          title: `ì•Œë ¤ì§„ ì·¨ì•½í•œ ë²„ì „ ê°ì§€: ${packageName}`,
          recommendation: `ìµœì‹  ë²„ì „ìœ¼ë¡œ ì—…ë°ì´íŠ¸ í•„ìš”`,
          timestamp: new Date().toISOString()
        });
        
        this.updateStats(vulnerablePackage.severity);
      }
    });
  }

  // í•˜ë“œì½”ë”©ëœ ì‹œí¬ë¦¿ ê²€ì‚¬
  async scanHardcodedSecrets() {
    this.log('info', 'ğŸ” í•˜ë“œì½”ë”©ëœ ì‹œí¬ë¦¿ ê²€ì‚¬ ì‹œì‘...');
    
    const secretPatterns = [
      {
        name: 'API Keys',
        pattern: /(?:api[_-]?key|apikey)\s*[:=]\s*['"]([^'"]{20,})['"]/gi,
        severity: 'critical'
      },
      {
        name: 'Database URLs',
        pattern: /(?:database[_-]?url|db[_-]?url)\s*[:=]\s*['"]([^'"]+)['"]/gi,
        severity: 'critical'
      },
      {
        name: 'JWT Secrets',
        pattern: /(?:jwt[_-]?secret|secret[_-]?key)\s*[:=]\s*['"]([^'"]{16,})['"]/gi,
        severity: 'high'
      },
      {
        name: 'Passwords',
        pattern: /(?:password|pwd)\s*[:=]\s*['"]([^'"]{4,})['"]/gi,
        severity: 'high'
      },
      {
        name: 'Private Keys',
        pattern: /-----BEGIN (?:RSA )?PRIVATE KEY-----/gi,
        severity: 'critical'
      },
      {
        name: 'Generic Secrets',
        pattern: /(?:secret|token|key)\s*[:=]\s*['"][a-zA-Z0-9+/=]{20,}['"]/gi,
        severity: 'moderate'
      }
    ];
    
    const excludePatterns = [
      /node_modules/,
      /\.git/,
      /\.next/,
      /dist/,
      /build/,
      /coverage/,
      /\.env\.example/,
      /README\.md/
    ];
    
    const scanResults = [];
    
    try {
      // ì†ŒìŠ¤ ì½”ë“œ íŒŒì¼ ê²€ìƒ‰
      const { stdout: findResult } = await execAsync(
        'find . -type f \\( -name "*.js" -o -name "*.jsx" -o -name "*.ts" -o -name "*.tsx" -o -name "*.json" -o -name "*.env*" \\) -not -path "./node_modules/*" -not -path "./.next/*" -not -path "./.git/*"'
      );
      
      const files = findResult.trim().split('\n').filter(file => file);
      
      for (const file of files) {
        // ì œì™¸ íŒ¨í„´ í™•ì¸
        if (excludePatterns.some(pattern => pattern.test(file))) {
          continue;
        }
        
        try {
          const content = fs.readFileSync(file, 'utf8');
          
          secretPatterns.forEach(pattern => {
            let match;
            while ((match = pattern.pattern.exec(content)) !== null) {
              // ì‹¤ì œ ì‹œí¬ë¦¿ì¸ì§€ í™•ì¸ (í…ŒìŠ¤íŠ¸ ê°’ ì œì™¸)
              const value = match[1] || match[0];
              if (this.isLikelySecret(value)) {
                const lineNumber = content.substring(0, match.index).split('\n').length;
                
                scanResults.push({
                  type: pattern.name,
                  file: file,
                  line: lineNumber,
                  severity: pattern.severity,
                  preview: this.maskSecret(match[0]),
                  timestamp: new Date().toISOString()
                });
                
                this.updateStats(pattern.severity);
              }
            }
          });
          
        } catch (readError) {
          this.log('debug', `íŒŒì¼ ì½ê¸° ì‹¤íŒ¨: ${file}`, readError);
        }
      }
      
      this.vulnerabilities.secrets = scanResults;
      this.log('success', `ì‹œí¬ë¦¿ ìŠ¤ìº” ì™„ë£Œ: ${scanResults.length}ê°œ ì ì¬ì  ì‹œí¬ë¦¿ ë°œê²¬`);
      
      return scanResults;
      
    } catch (error) {
      this.log('error', 'ì‹œí¬ë¦¿ ìŠ¤ìº” ì‹¤íŒ¨', error);
      return [];
    }
  }

  // ì‹œí¬ë¦¿ ê°€ëŠ¥ì„± íŒë‹¨
  isLikelySecret(value) {
    // í…ŒìŠ¤íŠ¸ë‚˜ ë”ë¯¸ ê°’ ì œì™¸
    const dummyValues = [
      'test', 'example', 'dummy', 'placeholder', 'your-key-here',
      '123456', 'password', 'secret', 'changeme', 'localhost'
    ];
    
    const lowerValue = value.toLowerCase();
    
    // ë”ë¯¸ ê°’ì´ë©´ false
    if (dummyValues.some(dummy => lowerValue.includes(dummy))) {
      return false;
    }
    
    // ê¸¸ì´ê°€ ì¶©ë¶„í•˜ê³  ë³µì¡í•œ ë¬¸ìì—´ì´ë©´ true
    if (value.length >= 20 && /[A-Za-z]/.test(value) && /[0-9]/.test(value)) {
      return true;
    }
    
    // íŠ¹ì • íŒ¨í„´ (API í‚¤ í˜•íƒœ)
    if (/^[A-Za-z0-9+/=]{32,}$/.test(value) || /^[A-Za-z0-9_-]{20,}$/.test(value)) {
      return true;
    }
    
    return false;
  }

  // ì‹œí¬ë¦¿ ë§ˆìŠ¤í‚¹
  maskSecret(secret) {
    if (secret.length <= 8) {
      return '*'.repeat(secret.length);
    }
    
    const start = secret.substring(0, 3);
    const end = secret.substring(secret.length - 3);
    const middle = '*'.repeat(Math.min(secret.length - 6, 20));
    
    return `${start}${middle}${end}`;
  }

  // ì˜ì¡´ì„± ë¼ì´ì„ ìŠ¤ ê²€ì‚¬
  async checkLicenses() {
    this.log('info', 'ğŸ“œ ì˜ì¡´ì„± ë¼ì´ì„ ìŠ¤ ê²€ì‚¬ ì‹œì‘...');
    
    try {
      // license-checker ì„¤ì¹˜ ì—¬ë¶€ í™•ì¸
      try {
        execSync('npm list license-checker --depth=0', { stdio: 'ignore' });
      } catch (error) {
        this.log('info', 'license-checker ì„¤ì¹˜ ì¤‘...');
        execSync('npm install --no-save license-checker', { stdio: 'inherit' });
      }
      
      // ë¼ì´ì„ ìŠ¤ ì •ë³´ ìˆ˜ì§‘
      const { stdout } = await execAsync('npx license-checker --json --production --excludePrivatePackages');
      const licenses = JSON.parse(stdout);
      
      // ë¬¸ì œê°€ ë  ìˆ˜ ìˆëŠ” ë¼ì´ì„ ìŠ¤
      const problematicLicenses = [
        'GPL-3.0', 'GPL-2.0', 'GPL-1.0',
        'AGPL-3.0', 'AGPL-1.0',
        'LGPL-3.0', 'LGPL-2.1',
        'CPAL-1.0', 'EPL-1.0', 'EPL-2.0',
        'EUPL-1.1', 'EUPL-1.2'
      ];
      
      const licenseIssues = [];
      
      Object.keys(licenses).forEach(packageName => {
        const licenseInfo = licenses[packageName];
        const license = licenseInfo.licenses;
        
        if (problematicLicenses.some(problematic => 
          license && license.toUpperCase().includes(problematic.toUpperCase())
        )) {
          licenseIssues.push({
            package: packageName,
            license: license,
            severity: 'moderate',
            issue: 'ìƒì—…ì  ì‚¬ìš©ì— ì œí•œì´ ìˆì„ ìˆ˜ ìˆëŠ” ë¼ì´ì„ ìŠ¤',
            timestamp: new Date().toISOString()
          });
          
          this.updateStats('moderate');
        }
        
        // ë¼ì´ì„ ìŠ¤ ëˆ„ë½ ì²´í¬
        if (!license || license === 'UNKNOWN') {
          licenseIssues.push({
            package: packageName,
            license: 'UNKNOWN',
            severity: 'low',
            issue: 'ë¼ì´ì„ ìŠ¤ ì •ë³´ ëˆ„ë½',
            timestamp: new Date().toISOString()
          });
          
          this.updateStats('low');
        }
      });
      
      this.vulnerabilities.licenses = licenseIssues;
      this.log('success', `ë¼ì´ì„ ìŠ¤ ê²€ì‚¬ ì™„ë£Œ: ${licenseIssues.length}ê°œ ì´ìŠˆ ë°œê²¬`);
      
      return licenseIssues;
      
    } catch (error) {
      this.log('error', 'ë¼ì´ì„ ìŠ¤ ê²€ì‚¬ ì‹¤íŒ¨', error);
      return [];
    }
  }

  // ë³´ì•ˆ í—¤ë” ê²€ì¦ (ë°°í¬ëœ ì‚¬ì´íŠ¸)
  async checkSecurityHeaders() {
    this.log('info', 'ğŸ›¡ï¸ ë³´ì•ˆ í—¤ë” ê²€ì¦ ì‹œì‘...');
    
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://dduksang.com';
    
    if (!baseUrl || baseUrl.includes('localhost')) {
      this.log('info', 'ë¡œì»¬ í™˜ê²½ - ë³´ì•ˆ í—¤ë” ê²€ì‚¬ ìŠ¤í‚µ');
      return [];
    }
    
    try {
      const response = await this.makeHttpRequest(baseUrl);
      const headers = response.headers;
      
      const securityHeaders = [
        {
          name: 'Strict-Transport-Security',
          required: true,
          severity: 'high',
          description: 'HTTPS ê°•ì œë¥¼ ìœ„í•œ HSTS í—¤ë”'
        },
        {
          name: 'X-Content-Type-Options',
          required: true,
          severity: 'moderate',
          expectedValue: 'nosniff',
          description: 'MIME íƒ€ì… ìŠ¤ë‹ˆí•‘ ë°©ì§€'
        },
        {
          name: 'X-Frame-Options',
          required: true,
          severity: 'moderate',
          expectedValue: ['DENY', 'SAMEORIGIN'],
          description: 'Clickjacking ê³µê²© ë°©ì§€'
        },
        {
          name: 'X-XSS-Protection',
          required: false,
          severity: 'low',
          expectedValue: '1; mode=block',
          description: 'XSS í•„í„°ë§ í™œì„±í™”'
        },
        {
          name: 'Content-Security-Policy',
          required: true,
          severity: 'high',
          description: 'CSPë¥¼ í†µí•œ XSS ë° ë°ì´í„° ì£¼ì… ê³µê²© ë°©ì§€'
        },
        {
          name: 'Referrer-Policy',
          required: false,
          severity: 'low',
          expectedValue: 'strict-origin-when-cross-origin',
          description: 'Referrer ì •ë³´ ì œì–´'
        }
      ];
      
      const headerIssues = [];
      
      securityHeaders.forEach(securityHeader => {
        const headerValue = headers[securityHeader.name.toLowerCase()];
        
        if (!headerValue) {
          if (securityHeader.required) {
            headerIssues.push({
              type: 'missing_header',
              header: securityHeader.name,
              severity: securityHeader.severity,
              description: `í•„ìˆ˜ ë³´ì•ˆ í—¤ë” ëˆ„ë½: ${securityHeader.description}`,
              recommendation: `${securityHeader.name} í—¤ë” ì¶”ê°€ í•„ìš”`,
              timestamp: new Date().toISOString()
            });
            
            this.updateStats(securityHeader.severity);
          }
        } else if (securityHeader.expectedValue) {
          const expectedValues = Array.isArray(securityHeader.expectedValue) 
            ? securityHeader.expectedValue 
            : [securityHeader.expectedValue];
          
          if (!expectedValues.some(expected => 
            headerValue.toLowerCase().includes(expected.toLowerCase())
          )) {
            headerIssues.push({
              type: 'weak_header',
              header: securityHeader.name,
              currentValue: headerValue,
              expectedValue: securityHeader.expectedValue,
              severity: 'low',
              description: `ë³´ì•ˆ í—¤ë” ê°’ì´ ê¶Œì¥ì‚¬í•­ê³¼ ë‹¤ë¦„`,
              timestamp: new Date().toISOString()
            });
            
            this.updateStats('low');
          }
        }
      });
      
      this.vulnerabilities.headers = headerIssues;
      this.log('success', `ë³´ì•ˆ í—¤ë” ê²€ì¦ ì™„ë£Œ: ${headerIssues.length}ê°œ ì´ìŠˆ ë°œê²¬`);
      
      return headerIssues;
      
    } catch (error) {
      this.log('error', 'ë³´ì•ˆ í—¤ë” ê²€ì¦ ì‹¤íŒ¨', error);
      return [];
    }
  }

  // HTTP ìš”ì²­ ìœ í‹¸ë¦¬í‹°
  makeHttpRequest(url) {
    return new Promise((resolve, reject) => {
      https.get(url, (response) => {
        let data = '';
        
        response.on('data', chunk => {
          data += chunk;
        });
        
        response.on('end', () => {
          resolve({
            statusCode: response.statusCode,
            headers: response.headers,
            data: data
          });
        });
      }).on('error', reject);
    });
  }

  // í†µê³„ ì—…ë°ì´íŠ¸
  updateStats(severity) {
    this.stats.totalIssues++;
    this.stats[severity] = (this.stats[severity] || 0) + 1;
  }

  // ì¢…í•© ë³´ì•ˆ ìŠ¤ìº” ì‹¤í–‰
  async runFullScan() {
    this.log('info', 'ğŸš€ ì¢…í•© ë³´ì•ˆ ìŠ¤ìº” ì‹œì‘...');
    const scanStart = Date.now();
    
    try {
      // ë³‘ë ¬ë¡œ ëª¨ë“  ìŠ¤ìº” ì‹¤í–‰
      await Promise.all([
        this.runNpmAudit(),
        this.scanHardcodedSecrets(),
        this.checkLicenses(),
        this.checkSecurityHeaders()
      ]);
      
      const scanDuration = Date.now() - scanStart;
      this.log('success', `ë³´ì•ˆ ìŠ¤ìº” ì™„ë£Œ (${scanDuration}ms)`);
      
      // ê²°ê³¼ ë¶„ì„ ë° ë¦¬í¬íŠ¸ ìƒì„±
      return this.generateSecurityReport();
      
    } catch (error) {
      this.log('error', 'ë³´ì•ˆ ìŠ¤ìº” ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', error);
      throw error;
    }
  }

  // ë³´ì•ˆ ë¦¬í¬íŠ¸ ìƒì„±
  generateSecurityReport() {
    this.log('info', 'ğŸ“Š ë³´ì•ˆ ë¦¬í¬íŠ¸ ìƒì„± ì¤‘...');
    
    const report = {
      timestamp: new Date().toISOString(),
      summary: {
        totalIssues: this.stats.totalIssues,
        critical: this.stats.critical || 0,
        high: this.stats.high || 0,
        moderate: this.stats.moderate || 0,
        low: this.stats.low || 0,
        info: this.stats.info || 0
      },
      vulnerabilities: this.vulnerabilities,
      recommendations: this.generateRecommendations()
    };
    
    // ì½˜ì†” ì¶œë ¥
    this.printSecurityReport(report);
    
    // íŒŒì¼ë¡œ ì €ì¥
    if (this.options.outputFormat === 'json') {
      this.saveJsonReport(report);
    }
    
    // SARIF í˜•ì‹ (GitHub Security Tabìš©)
    if (this.options.outputFormat === 'sarif') {
      this.saveSarifReport(report);
    }
    
    return report;
  }

  // ê¶Œì¥ì‚¬í•­ ìƒì„±
  generateRecommendations() {
    const recommendations = [];
    
    // NPM ì·¨ì•½ì 
    if (this.vulnerabilities.npm.length > 0) {
      recommendations.push({
        category: 'dependencies',
        priority: 'high',
        action: 'npm audit fix ì‹¤í–‰ìœ¼ë¡œ ìë™ ìˆ˜ì • ê°€ëŠ¥í•œ ì·¨ì•½ì  í•´ê²°',
        details: `${this.vulnerabilities.npm.length}ê°œì˜ NPM ì·¨ì•½ì ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.`
      });
    }
    
    // í•˜ë“œì½”ë”©ëœ ì‹œí¬ë¦¿
    if (this.vulnerabilities.secrets.length > 0) {
      recommendations.push({
        category: 'secrets',
        priority: 'critical',
        action: 'í•˜ë“œì½”ë”©ëœ ì‹œí¬ë¦¿ì„ í™˜ê²½ë³€ìˆ˜ë¡œ ì´ë™',
        details: `${this.vulnerabilities.secrets.length}ê°œì˜ ì ì¬ì  ì‹œí¬ë¦¿ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.`
      });
    }
    
    // ë¼ì´ì„ ìŠ¤ ì´ìŠˆ
    if (this.vulnerabilities.licenses.length > 0) {
      recommendations.push({
        category: 'licensing',
        priority: 'moderate',
        action: 'ë¬¸ì œê°€ ë  ìˆ˜ ìˆëŠ” ë¼ì´ì„ ìŠ¤ë¥¼ ê°€ì§„ íŒ¨í‚¤ì§€ ê²€í†  ë° ëŒ€ì²´',
        details: `${this.vulnerabilities.licenses.length}ê°œì˜ ë¼ì´ì„ ìŠ¤ ì´ìŠˆê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.`
      });
    }
    
    // ë³´ì•ˆ í—¤ë”
    if (this.vulnerabilities.headers.length > 0) {
      recommendations.push({
        category: 'headers',
        priority: 'high',
        action: 'Next.js ì„¤ì •ì— ë³´ì•ˆ í—¤ë” ì¶”ê°€',
        details: `${this.vulnerabilities.headers.length}ê°œì˜ ë³´ì•ˆ í—¤ë” ì´ìŠˆê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.`
      });
    }
    
    return recommendations;
  }

  // ì½˜ì†” ë¦¬í¬íŠ¸ ì¶œë ¥
  printSecurityReport(report) {
    console.log('\n' + '='.repeat(60));
    this.log('info', 'ğŸ›¡ï¸ ë³´ì•ˆ ìŠ¤ìº” ê²°ê³¼ ë¦¬í¬íŠ¸');
    console.log('='.repeat(60));
    
    // ìš”ì•½
    console.log(`\nğŸ“Š ìš”ì•½:`);
    console.log(`  ì´ ì´ìŠˆ: ${report.summary.totalIssues}ê°œ`);
    console.log(`  ğŸš¨ Critical: ${report.summary.critical}ê°œ`);
    console.log(`  âš ï¸  High: ${report.summary.high}ê°œ`);
    console.log(`  ğŸ“‹ Moderate: ${report.summary.moderate}ê°œ`);
    console.log(`  â„¹ï¸  Low: ${report.summary.low}ê°œ`);
    
    // ì¹´í…Œê³ ë¦¬ë³„ ì„¸ë¶€ì‚¬í•­
    if (report.vulnerabilities.npm.length > 0) {
      console.log(`\nğŸ“¦ NPM ì·¨ì•½ì  (${report.vulnerabilities.npm.length}ê°œ):`);
      report.vulnerabilities.npm.slice(0, 5).forEach(vuln => {
        console.log(`  â€¢ ${vuln.package} (${vuln.severity}): ${vuln.title}`);
      });
      if (report.vulnerabilities.npm.length > 5) {
        console.log(`  ... ë° ${report.vulnerabilities.npm.length - 5}ê°œ ì¶”ê°€`);
      }
    }
    
    if (report.vulnerabilities.secrets.length > 0) {
      console.log(`\nğŸ” ì‹œí¬ë¦¿ ê²€ì‚¬ (${report.vulnerabilities.secrets.length}ê°œ):`);
      report.vulnerabilities.secrets.slice(0, 3).forEach(secret => {
        console.log(`  â€¢ ${secret.file}:${secret.line} (${secret.severity}): ${secret.type}`);
      });
      if (report.vulnerabilities.secrets.length > 3) {
        console.log(`  ... ë° ${report.vulnerabilities.secrets.length - 3}ê°œ ì¶”ê°€`);
      }
    }
    
    // ê¶Œì¥ì‚¬í•­
    if (report.recommendations.length > 0) {
      console.log(`\nğŸ’¡ ê¶Œì¥ì‚¬í•­:`);
      report.recommendations.forEach((rec, index) => {
        console.log(`  ${index + 1}. [${rec.priority.toUpperCase()}] ${rec.action}`);
        console.log(`     ${rec.details}`);
      });
    }
    
    // ì „ì²´ ê²°ê³¼ í‰ê°€
    const riskLevel = this.assessOverallRisk(report.summary);
    console.log(`\nğŸ¯ ì „ì²´ ìœ„í—˜ë„: ${riskLevel.level} (${riskLevel.description})`);
    
    console.log('='.repeat(60));
  }

  // ì „ì²´ ìœ„í—˜ë„ í‰ê°€
  assessOverallRisk(summary) {
    if (summary.critical > 0) {
      return {
        level: 'ğŸš¨ Critical',
        description: 'ì¦‰ì‹œ ì¡°ì¹˜ê°€ í•„ìš”í•œ ì‹¬ê°í•œ ë³´ì•ˆ ì´ìŠˆ ì¡´ì¬'
      };
    }
    
    if (summary.high >= 3) {
      return {
        level: 'ğŸ”´ High',
        description: 'ì—¬ëŸ¬ ë†’ì€ ìœ„í—˜ë„ ì´ìŠˆë¡œ ì¸í•œ ë†’ì€ ë³´ì•ˆ ìœ„í—˜'
      };
    }
    
    if (summary.high > 0 || summary.moderate >= 5) {
      return {
        level: 'ğŸŸ¡ Moderate',
        description: 'ë³´ì•ˆ ì´ìŠˆê°€ ìˆìœ¼ë‚˜ ê´€ë¦¬ ê°€ëŠ¥í•œ ìˆ˜ì¤€'
      };
    }
    
    if (summary.moderate > 0 || summary.low >= 10) {
      return {
        level: 'ğŸŸ¢ Low',
        description: 'ê²½ë¯¸í•œ ë³´ì•ˆ ì´ìŠˆë“¤ì´ ìˆìœ¼ë‚˜ ì–‘í˜¸í•œ ìƒíƒœ'
      };
    }
    
    return {
      level: 'âœ… Excellent',
      description: 'ë³´ì•ˆ ì´ìŠˆê°€ ë°œê²¬ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤'
    };
  }

  // JSON ë¦¬í¬íŠ¸ ì €ì¥
  saveJsonReport(report) {
    const filename = `security-report-${new Date().toISOString().split('T')[0]}.json`;
    const filepath = path.join(process.cwd(), 'security-reports', filename);
    
    try {
      // ë””ë ‰í† ë¦¬ ìƒì„±
      const dir = path.dirname(filepath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      
      fs.writeFileSync(filepath, JSON.stringify(report, null, 2));
      this.log('success', `JSON ë¦¬í¬íŠ¸ ì €ì¥ë¨: ${filepath}`);
    } catch (error) {
      this.log('error', 'JSON ë¦¬í¬íŠ¸ ì €ì¥ ì‹¤íŒ¨', error);
    }
  }

  // SARIF ë¦¬í¬íŠ¸ ì €ì¥ (GitHub Security Tabìš©)
  saveSarifReport(report) {
    const sarif = {
      version: '2.1.0',
      $schema: 'https://schemastore.azurewebsites.net/schemas/json/sarif-2.1.0.json',
      runs: [{
        tool: {
          driver: {
            name: 'dduksangLAB Security Scanner',
            version: '1.0.0',
            informationUri: 'https://github.com/your-repo/security-scanner'
          }
        },
        results: this.convertToSarifResults(report)
      }]
    };
    
    const filename = `security-report-${new Date().toISOString().split('T')[0]}.sarif`;
    const filepath = path.join(process.cwd(), 'security-reports', filename);
    
    try {
      const dir = path.dirname(filepath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      
      fs.writeFileSync(filepath, JSON.stringify(sarif, null, 2));
      this.log('success', `SARIF ë¦¬í¬íŠ¸ ì €ì¥ë¨: ${filepath}`);
    } catch (error) {
      this.log('error', 'SARIF ë¦¬í¬íŠ¸ ì €ì¥ ì‹¤íŒ¨', error);
    }
  }

  // SARIF í˜•ì‹ìœ¼ë¡œ ë³€í™˜
  convertToSarifResults(report) {
    const results = [];
    
    // NPM ì·¨ì•½ì 
    report.vulnerabilities.npm.forEach(vuln => {
      results.push({
        ruleId: 'npm-vulnerability',
        level: this.mapSeverityToSarif(vuln.severity),
        message: {
          text: `NPM ì·¨ì•½ì : ${vuln.title} in ${vuln.package}`
        },
        properties: {
          package: vuln.package,
          severity: vuln.severity
        }
      });
    });
    
    // í•˜ë“œì½”ë”©ëœ ì‹œí¬ë¦¿
    report.vulnerabilities.secrets.forEach(secret => {
      results.push({
        ruleId: 'hardcoded-secret',
        level: this.mapSeverityToSarif(secret.severity),
        message: {
          text: `í•˜ë“œì½”ë”©ëœ ì‹œí¬ë¦¿ ì˜ì‹¬: ${secret.type}`
        },
        locations: [{
          physicalLocation: {
            artifactLocation: {
              uri: secret.file
            },
            region: {
              startLine: secret.line
            }
          }
        }],
        properties: {
          type: secret.type,
          severity: secret.severity
        }
      });
    });
    
    return results;
  }

  // ì‹¬ê°ë„ë¥¼ SARIF ë ˆë²¨ë¡œ ë§¤í•‘
  mapSeverityToSarif(severity) {
    const mapping = {
      critical: 'error',
      high: 'error',
      moderate: 'warning',
      low: 'note',
      info: 'note'
    };
    
    return mapping[severity] || 'note';
  }
}

// CLI ì‹¤í–‰ ì²˜ë¦¬
async function main() {
  const args = process.argv.slice(2);
  
  const options = {
    outputFormat: args.includes('--json') ? 'json' : args.includes('--sarif') ? 'sarif' : 'console',
    severity: args.includes('--all-severity') ? ['critical', 'high', 'moderate', 'low', 'info'] : ['critical', 'high', 'moderate'],
    includeDevDeps: args.includes('--include-dev'),
    skipPatches: args.includes('--skip-patches')
  };
  
  const scanner = new VulnerabilityScanner(options);
  
  try {
    const report = await scanner.runFullScan();
    
    // CI/CDì—ì„œ ì‚¬ìš© ì‹œ ì¢…ë£Œ ì½”ë“œ ì„¤ì •
    if (process.env.CI === 'true') {
      const criticalIssues = report.summary.critical || 0;
      const highIssues = report.summary.high || 0;
      
      if (criticalIssues > 0) {
        console.log(`\nâŒ Critical ì´ìŠˆ ${criticalIssues}ê°œë¡œ ì¸í•´ ë¹Œë“œ ì‹¤íŒ¨`);
        process.exit(1);
      } else if (highIssues > 3) {
        console.log(`\nâš ï¸ High ì´ìŠˆ ${highIssues}ê°œê°€ ì„ê³„ê°’ì„ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤`);
        process.exit(1);
      }
    }
    
    console.log('\nâœ… ë³´ì•ˆ ìŠ¤ìº” ì™„ë£Œ');
    process.exit(0);
    
  } catch (error) {
    console.error('âŒ ë³´ì•ˆ ìŠ¤ìº” ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜:', error);
    process.exit(1);
  }
}

// ìŠ¤í¬ë¦½íŠ¸ ì§ì ‘ ì‹¤í–‰ì‹œì—ë§Œ main í•¨ìˆ˜ í˜¸ì¶œ
if (require.main === module) {
  main();
}

module.exports = VulnerabilityScanner;